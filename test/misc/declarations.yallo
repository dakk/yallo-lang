interface FA12 {
	entry transfer(to: address, value: int);
	entry getBalance(of: address, cb: int callback);
}


type getBalanceCallback = nat callback;

function aFunction(c: int callback, z: nat option): nat {
	123
}

// could be useful to add type parameters, maybe in the future
contract tzToken implements FA12 {
	field balances 	: (address, nat) map;
	field supply 	: nat;
	field symbol 	: string;

	// the constructor is used only to create an initial storage, or to create a parametrized contract 
	// storage from create_contract
	constructor(sup: nat) {
		this.supply = None;
		this.balances = Map.empty;
		this.symbol = None
	}

	entry transfer (to: address, amount: int) {
		failif(not (this.balances.has(Tezos.sender)), "ciao ");
		let b: nat = this.balances.get(Tezos.sender);
		let bto: int = if this.balances.has (to) then balances.get(to) else 0;
		this.balances.update(to, bto + amount);
		this.balances.update(Tezos.sender, b - amount);
		[]
	}

	entry getBalance (adr: address, callBack: int callback) {
		let op: operation = if this.balances.has(a) then callBack(this.balances.get(a)) else callBack(0);
		[op]
	}
}



const tzTokenAddress: address = @tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx;

contract usingTezToken {
	field balance: nat;

	entry getb() {
		// get an instance of contract, call getbalance passing address and the handleBalance entry
		let op: operation = tzToken.of(tzTokenAddress).getBalance(address, this.handleBalance);
		[op]
	}

	entry handleBalance(bal: nat) {
		this.balance = bal;
		[]
	}
}


contract creatingContract {
	entry test () {
		// create a new instance of tzToken (storage is inferred by field declaration) 
		// transferring 100tz, without a delegate
		let (addr: address, op: oepration) = Tezos.createContract (tzToken(12), 100mtz, None);
		[op]
	}
}