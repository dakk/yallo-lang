type tstate = enum (WaitingBorrower | Loaned | Expired | Executed | Terminated);

const loanBaker: key_hash = h"3423432";
const d28 = 86400 * 28; // aka Timestamp.oneDay
const d5 = 86400 * 5;

function addressOfToken(tokName: string): address {
	match tokName with 
	| "tzbtc" -> @tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx
	| _ -> fail ("unknown token: " + tokName)
}

interface IToken {
	entry transfer(tto: address, vval: nat);
	entry getBalance(off: address, cb: nat contract);
}


contract Token implements IToken {
	field balances: (address, nat) big_map;
	field totalSupply: nat;
	field symbol: string;

	constructor (supply: nat, symbol: string) {
		this.balances = BigMap.empty();
		this.totalSupply = supply;
		this.symbol = symbol;
	}

	entry transfer(from: address, tto: address, vval: nat) {
		assert (vval > 0);
		let a = this.balances.get(from, 0n);
		let b: nat = this.balances.get(tto, 0n);
		assert(a > vval);
		this.balances.update(from, a - vval);
		this.balances.update(tto, b + vval); 
		[]
	}

	entry borrow() {
		[]
	}

	entry getBalance(ad: address, cb: nat contract) {
		let b: nat = this.balances.get(ad, 0n);
		let op: operation = cb(b);
		[op]
	}
}

contract Loan {
	field state: tstate;
	field lender: address;
	field borrower: address;
	field token: string;
	field amount: nat;
	field collateral: mutez;
	field expiration: timestamp;

	constructor (token: string, amount: nat, lender: address) {
		this.state = tstate#WaitingBorrower;
		this.token = token;
		this.amount = amount;
		this.lender = lender;
	}

	entry borrow() {
		assert (Tezos.amount() == this.collateral);
		assert (this.state == tstate#WaitingBorrower);
		
		let sdop = Tezos.setDelegate (Some (loanBaker));
		this.state = tstate#Loaned;
		this.borrower = Tezos.sender();
		this.expiration = Tezos.now() + d28;
		let op = IToken.of(addressOfToken (this.token)).transfer (Tezos.sender(), this.amount);
		[ sdop, op ]
	}

	entry refund() {
		assert (Tezos.sender() == this.borrower);
		assert (this.state == tstate#Loaned);
		assert (this.expiration < Tezos.now());

		this.state = tstate#CheckingRefund;
		
		[ IToken.of(addressOfToken (this.token)).getBalance(this.borrower, this.refundBalanceCallback) ]
	}

	entry refundBalanceCallback (bal: nat) {
		assert (Tezos.sender() == addressOfToken (this.token));
		assert (this.state == tstate#CheckingRefund);
		if (bal >= this.amount) then
			( this.state = tstate#Executed;
			[ Tezos.transfer (this.collateral, this.borrower) ] )
		else 
			( this.state = tstate#Loaned;
			[])
	}

	entry claim() {
		assert (this.state == tstate#Executed or this.state == tstate#Expired);
		failif (this.state == tstate#Executed and Tezos.now() < (this.expiration + d5));
		assert (Tezos.sender() == this.lender);

		this.state = tstate#Terminated;
		
		[ Tezos.transfer (Tezos.balance(), this.lender) ]
	}
}